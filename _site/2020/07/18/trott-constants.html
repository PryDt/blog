<!DOCTYPE html><html lang="en" ><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Jekyll v4.0.0" /><meta property="og:title" content="Finding Trott Constants" /><meta name="author" content="Pranoy Dutta" /><meta property="og:locale" content="en_US" /><meta name="description" content="My work in finding possible Trott constants." /><meta property="og:description" content="My work in finding possible Trott constants." /><link rel="canonical" href="prydt.xyz/b/2020/07/18/trott-constants.html" /><meta property="og:url" content="prydt.xyz/b/2020/07/18/trott-constants.html" /><meta property="og:site_name" content="Pry’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2020-07-18T00:00:00-05:00" /> <script type="application/ld+json"> {"description":"My work in finding possible Trott constants.","url":"prydt.xyz/b/2020/07/18/trott-constants.html","@type":"BlogPosting","dateModified":"2020-07-18T00:00:00-05:00","headline":"Finding Trott Constants","datePublished":"2020-07-18T00:00:00-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"prydt.xyz/b/2020/07/18/trott-constants.html"},"author":{"@type":"Person","name":"Pranoy Dutta"},"@context":"https://schema.org"}</script><title> Finding Trott Constants - Pry&#39;s Blog</title><link rel="shortcut icon" href="/b/favicon.png"><link rel="alternate" type="application/atom+xml" title="Pry's Blog" href="/b/atom.xml"><link rel="alternate" type="application/json" title="Pry's Blog" href="prydt.xyz/b/feed.json" /><link rel="sitemap" type="application/xml" title="sitemap" href="/b/sitemap.xml" /><style> *,:after,:before{box-sizing:border-box;background-color:inherit;color:inherit;margin:0;padding:0}body{font-family:system-ui, sans-serif;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;line-height:1.5;font-size:1rem;color:#16171a}nav ul{border-right:1px solid #edf2f7}a{color:#000;text-decoration-skip-ink:auto;text-decoration:underline}pre{margin:.5rem 0;padding:.5rem}.post p{margin:.5rem 0}.post h1,.post h2,.post h3,.post h4{margin:1rem 0}.post h2:first-child,.project h2:first-child,.photo h2:first-child{margin-top:0}.meta{margin:2rem 0}code{padding:.1rem}pre code{border:none}pre{padding:1rem;overflow-x:auto}img{max-width:100%}hr{background:#000;height:1px;border:0}header{flex-basis:10rem;flex-grow:1;position:relative}header a{text-decoration:none}header li{margin-bottom:.2rem;text-align:right;margin-right:2rem}header a.active{font-weight:bold}header,section{padding:1rem}blockquote{font-style:italic;border-left:5px solid #ececec;padding-left:1rem}h1,h2,h3,h4,h5{line-height:1;margin:1rem 0;font-weight:600}section h1:first-child{margin-top:0}strong,b{font-weight:bold}.photos ul{list-style:none}.photos li{margin-bottom:1.5rem}.photo picture,.project picture{margin-bottom:0.5rem}.posts ul,header ul{list-style:none}.posts li{align-items:center;display:flex;justify-content:space-between;margin-bottom:.5rem}.posts li a,.posts li div,.projects li a{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.posts li time,.projects li time{padding-left:1rem;white-space:nowrap;font-variant-numeric:tabular-nums}main{display:flex;flex-wrap:wrap;max-width:60rem;margin:2rem auto;padding:1rem}@media screen and (max-width: 45rem){header li{display:inline;margin-right:1rem}.logo{padding-bottom:1rem}header ul{border-bottom:1px solid #edf2f7;padding-bottom:2rem}nav ul{border-right:0px}.photos ul{margin-top:0.5rem}}section{flex-basis:0;flex-grow:999;min-width:70%;display:flex;flex-direction:column}figcaption{font-size:smaller}.highlight .hll{background-color:#ffffcc}.highlight{background:#ffffff}.highlight .c{color:#888888}.highlight .err{color:#FF0000;background-color:#FFAAAA}.highlight .k{color:#008800;font-weight:bold}.highlight .o{color:#333333}.highlight .ch{color:#888888}.highlight .cm{color:#888888}.highlight .cp{color:#557799}.highlight .cpf{color:#888888}.highlight .c1{color:#888888}.highlight .cs{color:#cc0000;font-weight:bold}.highlight .gd{color:#A00000}.highlight .ge{font-style:italic}.highlight .gr{color:#FF0000}.highlight .gh{color:#000080;font-weight:bold}.highlight .gi{color:#00A000}.highlight .go{color:#888888}.highlight .gp{color:#c65d09;font-weight:bold}.highlight .gs{font-weight:bold}.highlight .gu{color:#800080;font-weight:bold}.highlight .gt{color:#0044DD}.highlight .kc{color:#008800;font-weight:bold}.highlight .kd{color:#008800;font-weight:bold}.highlight .kn{color:#008800;font-weight:bold}.highlight .kp{color:#003388;font-weight:bold}.highlight .kr{color:#008800;font-weight:bold}.highlight .kt{color:#333399;font-weight:bold}.highlight .m{color:#6600EE;font-weight:bold}.highlight .s{background-color:#fff0f0}.highlight .na{color:#0000CC}.highlight .nb{color:#007020}.highlight .nc{color:#BB0066;font-weight:bold}.highlight .no{color:#003366;font-weight:bold}.highlight .nd{color:#555555;font-weight:bold}.highlight .ni{color:#880000;font-weight:bold}.highlight .ne{color:#FF0000;font-weight:bold}.highlight .nf{color:#0066BB;font-weight:bold}.highlight .nl{color:#997700;font-weight:bold}.highlight .nn{color:#0e84b5;font-weight:bold}.highlight .nt{color:#007700}.highlight .nv{color:#996633}.highlight .ow{color:#000000;font-weight:bold}.highlight .w{color:#bbbbbb}.highlight .mb{color:#6600EE;font-weight:bold}.highlight .mf{color:#6600EE;font-weight:bold}.highlight .mh{color:#005588;font-weight:bold}.highlight .mi{color:#0000DD;font-weight:bold}.highlight .mo{color:#4400EE;font-weight:bold}.highlight .sa{background-color:#fff0f0}.highlight .sb{background-color:#fff0f0}.highlight .sc{color:#0044DD}.highlight .dl{background-color:#fff0f0}.highlight .sd{color:#DD4422}.highlight .s2{background-color:#fff0f0}.highlight .se{color:#666666;font-weight:bold;background-color:#fff0f0}.highlight .sh{background-color:#fff0f0}.highlight .si{background-color:#eeeeee}.highlight .sx{color:#DD2200;background-color:#fff0f0}.highlight .sr{color:#000000;background-color:#fff0ff}.highlight .s1{background-color:#fff0f0}.highlight .ss{color:#AA6600}.highlight .bp{color:#007020}.highlight .fm{color:#0066BB;font-weight:bold}.highlight .vc{color:#336699}.highlight .vg{color:#dd7700;font-weight:bold}.highlight .vi{color:#3333BB}.highlight .vm{color:#996633}.highlight .il{color:#0000DD;font-weight:bold}</style></head><body><main role="main"><header role="banner"> <!--<h1 class="logo">Pry's Blog</h1>--><nav role="navigation"><ul><li><a href="/b" >Writing</a></li><li><a href="/b/about.html" >About</a></li><li><a href="/b/search.html" >Search</a></li><li><a href="/b/atom.xml" >Rss</a></li></ul></nav></header><section class="post"><h2>Finding Trott Constants</h2><p>So I recently had the pleasure of joining a research group in the field of measure theory and an interesting problem was brought up. The problem was whether Trott constants existed if you used to typical notion of a continued fraction.</p><blockquote><p>A Trott Constant is “a real number whose decimal digits are equal to the terms of its continued fraction.”</p></blockquote><blockquote><p>A continued fraction (CF) is a number in the form <code class="highlighter-rouge">[a; x, y, z ...]</code> which equals <code class="highlighter-rouge">a + 1/(x+1/(y+1/(z...)))</code>.</p></blockquote><p>But Trott in his work used numbers from 0-9 for each term (x,y,z…) in the continued fraction which is not typical. Usually you would only use positive integers from 1 onward.</p><p>The goal of this work is to try and find as many “pre-trott” constants as possible.</p><p>A pre-trott constant is a continued fraction and decimal pair whose values match in decimal for all the digits in the terms of the continued fraction.</p><p>Ex: <code class="highlighter-rouge">[0; 3, 29, 5, 7]</code> which matches <code class="highlighter-rouge">0.32957039824396362</code>. It matches the first 5 digits which is all it needs to match for since that is the number of digits in the CF.</p><p>So our first step is to construct a function that takes a continued fraction and computes it as a real number with a given amount or precision (decimal places accurate).</p><p>We are using <code class="highlighter-rouge">mpmath</code> for arbitrary precision floating point arithmetic. Essentially, we can set the precision of the computation to be a certan number of decimal places but we shall set it at the minimum necessary as the larger the precision, the longer the computation.</p><p>Additionally, note that our CF representation will just be a simple list of numbers. We will not store the zero as the beginning number does not really matter in either representation.</p><h3 id="count-digits">Count Digits</h3><p>This is used to count the number of digits in our CF representation which will allow us to figure out how many decimal places to check for equivalence.</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">mpmath</span> <span class="kn">import</span> <span class="n">mp</span><span class="p">,</span> <span class="n">mpf</span>


<span class="k">def</span> <span class="nf">count_digits</span><span class="p">(</span><span class="n">cf_list</span><span class="p">):</span>
    <span class="s">"""A Function to count amount of digits in a list of numbers
    We will use this to figure out the amount of precision we want"""</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">cf_list</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># note: numbers are guaranteed to be positive
</span>            <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">//</span> <span class="mi">10</span>
            <span class="n">total</span> <span class="o">=</span> <span class="n">total</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">total</span>
</code></pre></div></div><p>We shall test the our count digits function.</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">99</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">count_digits</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</code></pre></div></div><p>output:</p><pre><code class="language-commandline">7
[100, 5, 7, 99]
</code></pre><h2 id="continued-fraction-to-real-number-conversion">Continued Fraction to Real Number conversion</h2><p>Here we perform the conversion from CF to real number via repeated divisions.</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">cf_to_real</span><span class="p">(</span><span class="n">cf_list</span><span class="p">,</span> <span class="n">precision</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">mp</span><span class="o">.</span><span class="n">extradps</span><span class="p">(</span><span class="n">precision</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># 0 is previous term
</span>        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">cf_list</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span> <span class="c1"># loop through list backwards
</span>            <span class="n">curr</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">mpf</span><span class="p">(</span><span class="n">item</span> <span class="o">+</span> <span class="n">curr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">curr</span>
</code></pre></div></div><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cf</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>

<span class="n">cf_to_real</span><span class="p">(</span><span class="n">cf</span><span class="p">,</span> <span class="n">count_digits</span><span class="p">(</span><span class="n">cf</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div><p>output:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mpf('0.32957039824396362')
</code></pre></div></div><h2 id="continued-fraction-to-expected-trott-constant-approximation">Continued Fraction to Expected Trott Constant approximation</h2><p>Here we are calculating what the real number needs to equal if this CF is a trott constant approximate.</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">cf_to_trott_approx</span><span class="p">(</span><span class="n">cf_list</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">"0.{}"</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="s">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="n">cf_list</span><span class="p">)))</span>
</code></pre></div></div><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cf</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="n">cf_to_trott_approx</span><span class="p">(</span><span class="n">cf</span><span class="p">)</span>
</code></pre></div></div><p>output:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>'0.32957'
</code></pre></div></div><h2 id="check-if-cf-form-has-equal-real-and-expected-values">Check if CF form has equal real and expected values</h2><p>Here we are checking if the real number representation of the CF matches the digits in the terms of the CF.</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">valid_trott</span><span class="p">(</span><span class="n">cf_list</span><span class="p">):</span>
    <span class="n">precision</span> <span class="o">=</span> <span class="n">count_digits</span><span class="p">(</span><span class="n">cf_list</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>
    <span class="k">with</span> <span class="n">mp</span><span class="o">.</span><span class="n">extradps</span><span class="p">(</span><span class="n">precision</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">real</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">cf_to_real</span><span class="p">(</span><span class="n">cf_list</span><span class="p">,</span> <span class="n">precision</span><span class="p">))[:</span><span class="n">precision</span><span class="p">]</span>
        <span class="n">want</span> <span class="o">=</span> <span class="n">cf_to_trott_approx</span><span class="p">(</span><span class="n">cf_list</span><span class="p">)</span>
        <span class="c1"># print("{} {}".format(real, want)) # for debugging
</span>        <span class="k">return</span> <span class="n">real</span> <span class="o">==</span> <span class="n">want</span>
</code></pre></div></div><p>Testing the <code class="highlighter-rouge">valid_trott</code> function.</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">valid_trott</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">29</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">]))</span> <span class="c1"># true
</span><span class="k">print</span><span class="p">(</span><span class="n">valid_trott</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">29</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">]))</span> <span class="c1"># false
</span><span class="k">print</span><span class="p">(</span><span class="n">valid_trott</span><span class="p">([</span><span class="mi">3</span><span class="p">]))</span> <span class="c1"># true
</span><span class="k">print</span><span class="p">(</span><span class="n">valid_trott</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">30</span><span class="p">]))</span> <span class="c1"># false
</span><span class="k">print</span><span class="p">(</span><span class="n">valid_trott</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">29</span><span class="p">]))</span> <span class="c1"># true
</span><span class="k">print</span><span class="p">(</span><span class="n">valid_trott</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">333329</span><span class="p">]))</span> <span class="c1"># true
</span><span class="k">print</span><span class="p">(</span><span class="n">valid_trott</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3333329</span><span class="p">]))</span> <span class="c1"># true
</span><span class="k">print</span><span class="p">(</span><span class="n">valid_trott</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">33333329</span><span class="p">]))</span> <span class="c1"># true
</span></code></pre></div></div><p>output:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>True
False
True
False
True
True
True
True
</code></pre></div></div><h2 id="testing-for-any-possible-pre-trott-constant-3-terms-long">Testing for any possible Pre Trott constant 3 terms long</h2><p>This is the general structure of what we wish to do to check if there are n-item long valid trott constants. However doing this many nested for-loops gets tedious and it is actually not possible to general to an nth degree so we must use a recursive technique known as backtracking.</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ITEM_MAX</span> <span class="o">=</span> <span class="mi">1000000</span>

<span class="c1"># for-loop solution (NOT backtracking)
</span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ITEM_MAX</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">valid_trott</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ITEM_MAX</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">valid_trott</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">ITEM_MAX</span><span class="p">):</span>
                    <span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">valid_trott</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                        <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</code></pre></div></div><p>output:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[3]
[3, 29]
[3, 29, 5]
[3, 29, 54]
[3, 29, 545]
[3, 29, 5454]
[3, 29, 54545]
[3, 29, 545454]
[3, 329]
[3, 329, 9]
[3, 329, 95]
[3, 329, 959]
[3, 329, 9595]
[3, 329, 95951]
[3, 329, 959514]
[3, 3329]
[3, 3329, 9]
[3, 3329, 99]
[3, 3329, 995]
[3, 3329, 9959]
[3, 3329, 99599]
[3, 3329, 995995]
[3, 33329]
[3, 33329, 9]
[3, 33329, 99]
[3, 33329, 999]
[3, 33329, 9995]
[3, 33329, 99959]
[3, 33329, 999599]
[3, 333329]
[3, 333329, 9]
[3, 333329, 99]
[3, 333329, 999]
[3, 333329, 9999]
[3, 333329, 99996]
[3, 333329, 999960]
</code></pre></div></div><p>Here we can see that the first term must be a 3 to continue, 10 works at first but immediately dies out. The second term also is quite interesting as it looks like it must be 29, 329, 3329, and so on.</p><p>This is already a useful result in that we can generalize and say that we can find a pre trott constant that is equal up to any N. (If we wanted a pre trott that is equal to 20 digits we could just have <code class="highlighter-rouge">[0; 3, 333333333333333329]</code>.)</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">prev</span> <span class="o">=</span> <span class="mi">29</span> 
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">20</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="n">prev</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">i</span><span class="p">)]</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">valid_trott</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1"># print only the valid approximations
</span></code></pre></div></div><p>output:</p><div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[3, 329]
[3, 3329]
[3, 33329]
[3, 333329]
[3, 3333329]
[3, 33333329]
[3, 333333329]
[3, 3333333329]
[3, 33333333329]
[3, 333333333329]
[3, 3333333333329]
[3, 33333333333329]
[3, 333333333333329]
[3, 3333333333333329]
[3, 33333333333333329]
[3, 333333333333333329]
[3, 3333333333333333329]
</code></pre></div></div><p>The above is just a way to show that the repeating 3s at the beginning are valid pre trotts.</p><h2 id="backtracking-solution">Backtracking Solution</h2><blockquote><p>backtracking is the best way to do a brute force for all permutations in a general case.</p></blockquote><p>Here we will take what we do in each of the for-loops in the code above and call this function recursively. I will set more limiting restrictions on this version as the above code actually does take a bit of time to run just for 3 items of in the range of <code class="highlighter-rouge">[1, 1000000]</code>.</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">trott_backtracking</span><span class="p">(</span><span class="n">current_cf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">max_items</span><span class="p">,</span> <span class="n">max_size</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">max_items</span><span class="p">:</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_size</span><span class="p">):</span>
            <span class="n">new_cf</span> <span class="o">=</span> <span class="n">current_cf</span> <span class="o">+</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">valid_trott</span><span class="p">(</span><span class="n">new_cf</span><span class="p">):</span>
                <span class="n">valid</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_cf</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">valid</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">valid</span><span class="p">:</span>
                <span class="c1"># These branches are still alive
</span>                <span class="k">print</span><span class="p">(</span><span class="s">"VALID: {}"</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)),</span> <span class="nb">file</span><span class="o">=</span><span class="nb">file</span><span class="p">)</span>
                <span class="n">trott_backtracking</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">count</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_items</span><span class="p">,</span> <span class="n">max_size</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="nb">file</span><span class="p">)</span>
</code></pre></div></div><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"output1.txt"</span><span class="p">,</span> <span class="s">"w+"</span><span class="p">)</span> <span class="k">as</span> <span class="n">out</span><span class="p">:</span>
    <span class="n">trott_backtracking</span><span class="p">([],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
</code></pre></div></div><p>Since the output was long I moved it to another file but it can be seen in <code class="highlighter-rouge">output1.txt</code>.</p><p>Now I just need to run this for much larger possible values.</p><div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"output3.txt"</span><span class="p">,</span> <span class="s">"w+"</span><span class="p">)</span> <span class="k">as</span> <span class="n">out</span><span class="p">:</span>
    <span class="n">trott_backtracking</span><span class="p">([],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
</code></pre></div></div><h2 id="todo">TODO</h2><p>There are a few improvements I want to add to the code soon. Currently it is only using one process and hence only one of my CPU cores.</p><ul class="task-list"><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />use <code class="highlighter-rouge">multiprocessing</code> module to parallelize code</li><li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled="disabled" />figure out a faster way to check for decimal equality than to convert to a string?</li></ul><p>That’s all for now. – Pry (Pranoy Dutta)</p><span class="meta"><time datetime="2020-07-18T00:00:00-05:00">July 18, 2020</time> &middot; <a href="/tag/math">math</a>, <a href="/tag/research">research</a></span> <script src="https://utteranc.es/client.js" repo="prydt/blog" issue-term="pathname" theme="github-light" crossorigin="anonymous" async> </script> <!--<span class="meta"><time datetime="2020-07-18T00:00:00-05:00">July 18, 2020</time> &middot; <a class="post" href="/tag/math">math</a>, <a class="post" href="/tag/research">research</a></span> --></section></main></body></html>
